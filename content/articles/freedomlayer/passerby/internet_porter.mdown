Title: Passerby Internet Porter
Date: 2017-08-10 15:21
Author: real

**work in progress!**

## Intro

The Passerby protocol allows routing of messages in a network of nodes, where
every node is directly connected to a few other predefined nodes.
Internet Porter is a mechanism for obtaining direct connections for Passerby
as TCP connections over the Internet.

## Initialization

Passerby Internet Porter begins with the following input:

- A list of known remote nodes: (ip, port)
- Maximum amount of simultaneous two sided TCP connections.


## Internet Porter messages KnownNodes messages

**RequestKnownNodes**

Request a list of known nodes from remote host.


**ResponseKnownNodes**

- A list (ip, port) of known nodes.

Right after sending this message, the TCP connection is closed.


## Direct connection messages between nodes

**Hello** (L0)

- nodePublicKey

This message is sent right after setting up the sending part of a two sided TCP
connection. It introduces nodeIdHash of the sender to the receiver.

**KeepAlive** (L0)

- randValue: A random value generated by the sender (128 bit).

This message is sent right after the first Hello message. In addition, it is
sent periodically. randValue is used like a timestamp in the EngineMessage
message. It allows to overcome replay attacks.

**EncMessage** (L0)

- encSymmetricKey == Encrypt{key=recipientPublicKey}
    - pastKeepaliveRandValue (A KeepAlive rand value from the near past)
    - symmetricKey
    - Sign{key=senderPublicKey}(keepaliveRandValue, symmetricKey)
- encDatagramData == Encrypt{key=symmetricKey, nonce=random}(
    pastKeepaliveRandValue, L1Content)

A message that contains an underlying Passerby routing engine message.

**ConnectionEstablished** (L1) // EncMessage

This message marks that the sender is actually the one that was stated in the
Hello message. This should be sent as soon as the first EncMessage, immediately
after Hello and KeepAlive messages were received.

**UserMessage** (L1) // EncMessage

- content

Allows to send user messages over the connection.


## The types of connections between nodes

We distinct between two types of TCP connections in the Passerby Internet
Porter protocol:

1. Request known nodes connection.
2. Passerby direct connection.

A node can determine the type of connection formed according to the first
message sent. If the first message sent is RequestKnownNodes, then this
connection is used to request for known nodes. If the first message sent is
Hello, then this is possibly a beginning of a direct Passerby connection
between two nodes.

In order to exchange known nodes, a node $a$ opens a TCP connection to node $b$
and sends RequestKnownNodes message. In turn, $b$ returns a
ResponseKnownMessage message and then closes the connection.

If $a$ wants to open a direct Passerby connection to a node $b$, the following
messages will be sent:

1. $a$ creates a TCP connection to $b$.
2. $a$ sends Hello message to $b$. This message contains $a$'s public key.
3. $a$ sends KeepAlive message to $b$.
4. If $b$ is not available for another direct Passerby connection, $b$ closes
   the connection.
5. Otherwise, $b$ sends Hello message to $a$, followed by a KeepAlive message.
6. $a$ and $b$ can now send EngineMessage messages using the values from the
   KeepAlive messages.


## Dealing with races in Passerby direct connections

It is possible that $a$ opens a Passerby direct connection to $b$, and at about
the same time $b$ opens a Passerby direct connection to $a$. In this situation
$a$ and $b$ will have two simultaneous TCP connections.

Let clientPublicKey be the public key of the node who initiated the TCP
connection (The client), and let serverPublicKey be the public key of the node
who received the connection (The server). For such a Passerby direct connection
we define the following to be a Passerby connection ident:

```
minValue <-- min(sha256(clientPublicKey), sha256(serverPublicKey))
maxValue <-- max(sha256(clientPublicKey), sha256(serverPublicKey))

connectionIdent <--sha256(minValue, maxValue)
```

If $a$ and $b$ have two simultaneous Passerby direct connections, each of those
connections should have a connectionIdent. Those two values will have different
values with high probability. (Note that we don't allow Passerby direct
connections where two sides have the same public key).

Consider without loss of generality the node $a$. Assume that $a$ and $b$ have
a Passerby direct connection. Now assume that $b$ opens another Passerby direct
connection to $a$. $a$ will close the connection that has the lower
connectionIdent.

This is done because at the same time $b$ will realize that he has two
Passerby direct connections to the node $a$. $b$ will also calculate the
connectionIdent for both connections and will close the one with the lowest
connectionIdent value. If the disconnection was done randomly, it could have
happened that $a$ and $b$ will close both connections, leaving now connection
open.


## Maintaining remote nodes list

Every node should maintain his list of remote nodes, or else in the future he
will lose contact with the network. An initial remote nodes list should be
obtained from somewhere (Possibly from the same place the software was
obtained, or from a friend).

Periodically a node picks a random entry from his list of remote nodes, and
query him with a KnownNodes message. If the node doesn't answer, his
liveliness is decreased. When the liveliness reaches $0$, the entry is removed
from the list of remote nodes.

The list of KnownNodes should be diversified. It should contain IP addresses
that look different enough. In addition, When forming a new KnownNodes
list from an old list, the new list should contain representation from nodes in
the old list. In other words, we expect that the new list will contain nodes
from every KnownNodes message sent by nodes in the old list.

