Title: Fragmentos fragmentation system
Date: 2017-08-29 15:18
Author: real

**work in progress!**

## Intro

Given two nodes $x$ and $y$ on the internet, if $x$ attempts to send a large
UDP datagram $y$, it is likely that the datagram will be fragmented, in the
lower IP layer, to a few IP packets. Those IP packets will be reconstructed
somewhere on a router on the way, or possibly at the endpoint $y$.

Traditional IP Packet fragmentation works by splitting a large IP packet into a
few smaller packets. The problem with this method is that the original large
packet is less likely to arrive at its destination, as the loss of any of the
fragments will lead to the loss of the original large packet. 

Thinking about a naive probabilistic model, if an IP packet sent from $x$ to
$y$ arrives at $y$ with probability $p$, then a datagram which was fragmented
to two IP packets will arrive at probability $p^2$. If $p = \frac{3}{4}$, then
$q := p^2 = \frac{9}{16}$, which represents much lower odds for successful
delivery.

This document presents a different fragmentation method which increases the
likelyhood of successful delivery given the model discussed above. For example,
Instead of splitting a large datagram into two packets, we create three shares
of the datagram in a way that every two shares are enough to reconstruct the
original datagram. 

In this case, if $x$ wants to send the datagram to $y$, $x$ sends all the three
shares of the datagram to $y$. In the naive model described above where the
odds of successful delivery for one IP packet are $p$, we obtain that the odds
for successful arrival for the complete datagram are 
$q := p^3 + 3\cdot p^2 \cdot (1-p)$. For $p = \frac{3}{4}$, this will result in
$q = 0.84375$. Surprisingly in this case $q > p$.


## Splitting a small chunk

Given a chunk of data $W$ of size $b$ bytes, we want to split it to $2b-1$
shares, so that every $b$ shares are enough to reconstruct the original chunk.

Using information theoretic considerations we can
conclude that each share should be of size at least $len(M) / b$, so that the
reconstruction algorithm gets at least $b \cdot (len(M) / b) = b$ bytes of input.

We will do this in a method similar to [Shamir's secret
sharing](https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing). We treat the
given chunk $W$ as the coefficients of a polynomial $P_W$ over the [Galois
field](https://en.wikipedia.org/wiki/Finite_field#GF.2816.29) $Gf(256)$. The
first byte of the message $W$ is considered to be the most coefficient of
monomial of the highest degree in the polynomial.

A share of the chunk $W$ is a pair of bytes $(i, P_W(i))$, for $0 \leq i < 2b -
1$. In other words, a share is a point that the polynomial $P$ goes through.

Given $b$ shares of the chunk $W$ we can always reconstruct a polynomial $Q$ of
degree $b-1$ that goes through the set of points provided as shares. For
example, we could do this using [Lagrange
interpolation](https://en.wikipedia.org/wiki/Lagrange_polynomial).

As $Q$ and $P_W$ are two polynomials of degree $b-1$ that agree on $b$ points,
they must be equal. Therefore using any $b$ shares we can reconstruct the
$P_W$ and the chunk $W$.

We picked $Gf(256)$ with modulo polynomial $x^8 + x^4 + x^3 + x^2 + 1$
(Represented at `0x1D` in byte form) as the underlying field. $GF(256)$ has
exactly $256$ elements, which means that we have an exact mapping between a
byte value and an element of the field, thus avoiding various encoding and
decoding problems.

On the other hand, the choice of $GF(256)$ imposes a limitation on the amount
of shares we can produce for one chunk. As every share $(i, P_W(i))$ should have
a unique $i$, we can have no more than $256$ shares. This means that $2b - 1
\leq 256$, hence $b \leq 128$.


## Splitting a large message

Given a message $M$ of certain size $len(M)$, we would like to split it to
$2b-1$ data shares, so that every $b$ data shares could be used to reconstruct
the original chunk of data. Note that in the previous section we solved this
problem for $M$ with $len(M) = b$. Here we want to solve this problem for a
message $M$ of arbitrary size.

First we divide $M$ into chunks of size $b$ bytes. If $len(M)$ is not
divisible by $b$, we add padding $0$ bytes to the end of $M$. This means that
the last chunk has possibly some $0$ bytes in the end.

For example, if $M$ is the message `\x12\x34\x56\x78\x90\xab\xcd\xef\x55` and
$b = 4$, we will get the following chunks:

```
\x12\x34\x56\x78
\x90\xab\xcd\xef
\x55\x00\x00\x00
```

Note that the last chunk has three $0$ padding bytes.

Next, we divide each chunk $W$ of size $b$ bytes into $2b-1$ small shares. We
do this as described in the previous section "splitting a chunk". For every
resulting small share $(i, P_W(i))$ we take the value $P_W(i)$ and add it to
data share number $i$.

Eventually we will have $2b - 1$ data shares, each one having $v := \lceil len(M) /
b \rceil$ bytes. Given that $M$ is divided to the chunks $W_0,  W_1, W_2
\dots W_{v-1}$, byte number $k$ in data share $i$ is $P_{W_k}(i)$.


TODO: Add a picture to explain the division here.


## Messages structure

TODO

## Protocol state machine

TODO: 
    - How buffering works. 
    - Timeouts?



