Title: Node discovery with landmarks based routing
Date: 2017-06-22 10:50
Author: real

### Abstract

Landmarks based routing allows efficient routing of messages between nodes in a
network. Given two nodes $x, y$ in a network $G$, $x$ can send a message to $y$
given that $x$ knows the network coordinate $Coord(y)$ of $y$.

Hence we need some method of translating a node id $y$ into his
network coordinate, $Coord(y)$.

We discuss here two methods of translation: Hashing of node id into uniform
valid coordinate, and the usage of overlay DHT.

### Hashing node ids into coordinates

Assume that we had some deterministic way of hashing a node id, $y$, into some
coordinate $H(y)$. (Note that $H(y)$ has no relation to $Coord(y)$).

The node $y$ will then calculate $H(y)$, obtaining some network coordinate.
$y$ will then find the node $z$ with network coordinate closest to $H(y)$, and
let $z$ keep $y$'s coordinate: $Coord(y)$.

If some node $x$ wants to send a message to $y$, $x$ will first calculate
$H(y)$. $H$ is deterministic, so $x$ will get the same value of $H(y)$ that $y$
got. $x$ will then find the node $z$ with a coordinate closest to $H(y)$, and
ask him for $Coord(y)$.

Finally, knowing $Coord(y)$, $x$ can send a message to $y$.

There are some requirements to make this technique work:

- The process of applying the function $H$, followed by finding a node with
  closest coordinate to the result of $H$ should distribute close to uniformly
  over the set of nodes. This is because we don't want that few nodes will keep
  the coordinates of most of the nodes in the network.

- The coordinate produced by $H$ should look like a "real coordinate". It
  should satisfy the triangle inequalities, and hopefully look like other
  coordinates in the network.


#### Generating random coordinates

We want to create a function $H: V(G) \rightarrow Coordinates$ that produces
deterministic results, even when invoked from different nodes. For this to
happen, we need to rely on some common knowledge that all nodes have.

We will rely on the knowledge of the coordinates of all the landmarks:
$Coord(l_i)$ for $1 \leq i \leq k$.

We examined a few algorithms of generating random coordinates that are uniform
over the set of nodes in the network. We introduce here two algorithms that
gave us good results.

#### `randomize_coord_landmarks_coords`

The first algorithm, called `randomize_coord_landmarks_coords`, does the
following to create a random coordinate: For entry $j$, we pick a random entry
of a random coordinate from all the coordinates $Coord(l_i)$, $1 \leq i \leq k$.

Example rust code for this algorithm:

```rust
pub fn randomize_coord_landmarks_coords<R: Rng>(landmarks: &Vec<usize>, coords: &Vec<Vec<u64>>,
                    mut rng: &mut R) -> Vec<u64> {

    let rand_landmark: Range<usize> = 
        Range::new(0, landmarks.len());
    let interval_size: u64 = 2_u64.pow(0_u32);

    let mut coord: Vec<u64> = vec![];
    for _ in 0 .. landmarks.len() {
        let mut cur_value = 0;
        for _ in 0 .. interval_size {
            cur_value += coords[landmarks[rand_landmark.ind_sample(&mut rng)]][rand_landmark.ind_sample(&mut rng)];
        }
        coord.push(cur_value);
    }
    coord
}
```

This algorithm is not very smart. It does not produce coordinates that satisfy
the triangle inequalities, but it does produce coordinates that distribute
somewhat uniformly over all the nodes in the network.

We include here some results for this algorithm, for small sized networks.
Explanation about how to read the result: $g$ means log in base 2 of the size
of the network. (For example, $g=9$ means a network of $512$ nodes).
We check against $4$ types of networks: 
- rand: A random network. Every node is connected to $`1.5 * \log(n)`$ other
  nodes.
- 2d: A two dimensional grid.
- rand+2d: A sum of a random network with a two dimensional grid.
- planar: A planar graph: Nodes are randomized in a two dimensional plane, and
  every node is connected to the closet $1.5 * \log(n)$ nodes.

$ni$ means network iteration. In this experiment we make two iterations for
every type of network. We do this to have more numbers to look at.

In this experiment we generate $n = |V(G)|$ random coordinates, and for each
coordinate we find the node with a coordinate closets to the generated coordinate.

For each node we count the amount of times it was the closest node to the
generated coordinate. `max_nr` is the maximum number of times we visited a
single node. If `max_nr` is very large, it means that only a few nodes were
visited during the experiment, and the algorithm chosen for randomizing
coordinates is not very uniform.

We also for every randomly generated coordinate how many nodes are fit to be
the node with closest node to this coordinate (There could be more than one).
`average_min_indices` is the average of this amount, over all the randomly
generated coordinates. It is usually $1$, because usually there is only one
closest node.

Parameters for this experiment:

- Amount of landmarks: $\log(n)^2$
- Tie breaking by randomizing edge distances: Done with interval $[0x10000,
  0x20000)$. (This helps with having a low `average_min_indices` value).

Results:

```
g=10; rand    ; ni=0 |max_nr =    8| average_min_indices = 1
g=10; rand    ; ni=1 |max_nr =    6| average_min_indices = 1.0009765625
g=10; 2d      ; ni=0 |max_nr =   11| average_min_indices = 1
g=10; 2d      ; ni=1 |max_nr =    7| average_min_indices = 1
g=10; rand+2d ; ni=0 |max_nr =   11| average_min_indices = 1.0009765625
g=10; rand+2d ; ni=1 |max_nr =    8| average_min_indices = 1.0009765625
g=10; planar  ; ni=0 |max_nr =   14| average_min_indices = 1
g=10; planar  ; ni=1 |max_nr =   15| average_min_indices = 1

g=11; rand    ; ni=0 |max_nr =    9| average_min_indices = 1.00048828125
g=11; rand    ; ni=1 |max_nr =    9| average_min_indices = 1.0009765625
g=11; 2d      ; ni=0 |max_nr =   11| average_min_indices = 1
g=11; 2d      ; ni=1 |max_nr =    8| average_min_indices = 1
g=11; rand+2d ; ni=0 |max_nr =   11| average_min_indices = 1.0004938271604937
g=11; rand+2d ; ni=1 |max_nr =    8| average_min_indices = 1
g=11; planar  ; ni=0 |max_nr =   14| average_min_indices = 1
g=11; planar  ; ni=1 |max_nr =   17| average_min_indices = 1

g=12; rand    ; ni=0 |max_nr =   15| average_min_indices = 1.000732421875
g=12; rand    ; ni=1 |max_nr =   16| average_min_indices = 1.000244140625
g=12; 2d      ; ni=0 |max_nr =   14| average_min_indices = 1
g=12; 2d      ; ni=1 |max_nr =   10| average_min_indices = 1
g=12; rand+2d ; ni=0 |max_nr =    8| average_min_indices = 1.000244140625
g=12; rand+2d ; ni=1 |max_nr =   11| average_min_indices = 1.00048828125
g=12; planar  ; ni=0 |max_nr =   13| average_min_indices = 1.000244140625
g=12; planar  ; ni=1 |max_nr =   21| average_min_indices = 1.000244140625

g=13; rand    ; ni=0 |max_nr =   26| average_min_indices = 1
g=13; rand    ; ni=1 |max_nr =   15| average_min_indices = 1.0001220703125
g=13; 2d      ; ni=0 |max_nr =   14| average_min_indices = 1
g=13; 2d      ; ni=1 |max_nr =   12| average_min_indices = 1.000246913580247
g=13; rand+2d ; ni=0 |max_nr =   18| average_min_indices = 1.0003703703703704
g=13; rand+2d ; ni=1 |max_nr =   18| average_min_indices = 1
g=13; planar  ; ni=0 |max_nr =   44| average_min_indices = 1
g=13; planar  ; ni=1 |max_nr =   19| average_min_indices = 1
```


#### `randomize_coord_rw_directional`

The first algorithm presented, `randomize_coord_landmarks_coords`, generates
random coordinates that don't satisfy the triangle inequality with respect to
the landmarks coordinates.

Let $d(x,y)$ is the length of the shortest path between $x$ and $y$ in the
network, $d$ is a metric over $V(G)$, the vertices of the network.
Let $\{l_1, \dots , l_k\} \subseteq V(G)$ be the chosen landmarks for the network.
For every node $x$, we define: 

$$Coord(x) := \{d(x,l_1), \dots , d(x, l_k)\}$$,

We then define:

$$mdist(Coord(x), Coord(y)) := \max_{1 \leq i \leq k} {|Coord(x)_i - Coord(y)_i|}$$

The virtual distance between $x$ and $y$.  $mdist$ satisfies $mdist(Coord(x),
Coord(y)) \leq d(x,y)$. This follows from the triangle inequality over the
metric $d$.

We call a coordinate $A$ valid if it satisfies all the triange inequalities
according to the metric $d$. In other words, $A_i + A_j \geq d(l_i,l_j) \geq
|A_i - A_j|$. Hence if two coordinates $A$ and $B$ are valid, $\alpha \cdot A +
(1 - \alpha) \cdot B$ is also a valid coordinate for $\alpha \in [0,1]$.
Therefore the set of valid coordinates is convex.

In addition, if a coordinate $A = (a_1, \dots , a_k)$ is valid, then $A +
\beta \cdot 1 = (a_1 + \beta, \dots, a_k + \beta)$ is also valid. Hence the set
of valid coordinates has infinite volume.

If we add an artificial constraint of $coord_i \leq const * \max_i
{Coord(l_j)_i}$, we get a bounded set of valid coordinates, with contraints
that are linear inequalities.











